{"title":"A fastai Learner from Scratch","markdown":{"yaml":{"title":"A fastai Learner from Scratch"},"headingText":"Data","containsRefs":false,"markdown":"\n\n\n\n\n\n\nThis final chapter (other than the conclusion and the online chapters) is going to look a bit different. It contains far more code and far less prose than the previous chapters. We will introduce new Python keywords and libraries without discussing them. This chapter is meant to be the start of a significant research project for you. You see, we are going to implement many of the key pieces of the fastai and PyTorch APIs from scratch, building on nothing other than the components that we developed in <<chapter_foundations>>! The key goal here is to end up with your own `Learner` class, and some callbacks—enough to be able to train a model on Imagenette, including examples of each of the key techniques we've studied. On the way to building `Learner`, we will create our own version of `Module`, `Parameter`, and parallel `DataLoader` so you have a very good idea of what those PyTorch classes do.\n\nThe end-of-chapter questionnaire is particularly important for this chapter. This is where we will be pointing you in the many interesting directions that you could take, using this chapter as your starting point. We suggest that you follow along with this chapter on your computer, and do lots of experiments, web searches, and whatever else you need to understand what's going on. You've built up the skills and expertise to do this in the rest of this book, so we think you are going to do great!\n\nLet's begin by gathering (manually) some data.\n\n\nHave a look at the source to `untar_data` to see how it works. We'll use it here to access the 160-pixel version of Imagenette for use in this chapter:\n\nTo access the image files, we can use `get_image_files`:\n\nOr we could do the same thing using just Python's standard library, with `glob`:\n\nIf you look at the source for `get_image_files`, you'll see it uses Python's `os.walk`; this is a faster and more flexible function than `glob`, so be sure to try it out.\n\nWe can open an image with the Python Imaging Library's `Image` class:\n\nThat's going to be the basis of our independent variable. For our dependent variable, we can use `Path.parent` from `pathlib`. First we'll need our vocab:\n\n...and the reverse mapping, thanks to `L.val2idx`:\n\nThat's all the pieces we need to put together our `Dataset`.\n\n### Dataset\n\nA `Dataset` in PyTorch can be anything that supports indexing (`__getitem__`) and `len`:\n\nWe need a list of training and validation filenames to pass to `Dataset.__init__`:\n\nNow we can try it out:\n\nAs you see, our dataset is returning the independent and dependent variables as a tuple, which is just what we need. We'll need to be able to collate these into a mini-batch. Generally this is done with `torch.stack`, which is what we'll use here:\n\nHere's a mini-batch with two items, for testing our `collate`:\n\nNow that we have a dataset and a collation function, we're ready to create `DataLoader`. We'll add two more things here: an optional `shuffle` for the training set, and a `ProcessPoolExecutor` to do our preprocessing in parallel. A parallel data loader is very important, because opening and decoding a JPEG image is a slow process. One CPU core is not enough to decode images fast enough to keep a modern GPU busy. Here's our `DataLoader` class:\n\nLet's try it out with our training and validation datasets:\n\nThis data loader is not much slower than PyTorch's, but it's far simpler. So if you're debugging a complex data loading process, don't be afraid to try doing things manually to help you see exactly what's going on.\n\nFor normalization, we'll need image statistics. Generally it's fine to calculate these on a single training mini-batch, since precision isn't needed here:\n\nOur `Normalize` class just needs to store these stats and apply them (to see why the `to_device` is needed, try commenting it out, and see what happens later in this notebook):\n\nWe always like to test everything we build in a notebook, as soon as we build it:\n\nHere `tfm_x` isn't just applying `Normalize`, but is also permuting the axis order from `NHWC` to `NCHW` (see <<chapter_convolutions>> if you need a reminder of what these acronyms refer to). PIL uses `HWC` axis order, which we can't use with PyTorch, hence the need for this `permute`.\n\nThat's all we need for the data for our model. So now we need the model itself!\n\n## Module and Parameter\n\nTo create a model, we'll need `Module`. To create `Module`, we'll need `Parameter`, so let's start there. Recall that in <<chapter_collab>> we said that the `Parameter` class \"doesn't actually add any functionality (other than automatically calling `requires_grad_` for us). It's only used as a \"marker\" to show what to include in `parameters`.\" Here's a definition which does exactly that:\n\nThe implementation here is a bit awkward: we have to define the special `__new__` Python method and use the internal PyTorch method `_make_subclass` because, as at the time of writing, PyTorch doesn't otherwise work correctly with this kind of subclassing or provide an officially supported API to do this. This may have been fixed by the time you read this, so look on the book's website to see if there are updated details.\n\nOur `Parameter` now behaves just like a tensor, as we wanted:\n\nNow that we have this, we can define `Module`:\n\nThe key functionality is in the definition of `parameters`:\n\n```python\nself.params + sum([m.parameters() for m in self.children], [])\n```\n\nThis means that we can ask any `Module` for its parameters, and it will return them, including all its child modules (recursively). But how does it know what its parameters are? It's thanks to implementing Python's special `__setattr__` method, which is called for us any time Python sets an attribute on a class. Our implementation includes this line:\n\n```python\nif isinstance(v,Parameter): self.register_parameters(v)\n```\n\nAs you see, this is where we use our new `Parameter` class as a \"marker\"—anything of this class is added to our `params`.\n\nPython's `__call__` allows us to define what happens when our object is treated as a function; we just call `forward` (which doesn't exist here, so it'll need to be added by subclasses). Before we do, we'll call a hook, if it's defined. Now you can see that PyTorch hooks aren't doing anything fancy at all—they're just calling any hooks that have been registered.\n\nOther than these pieces of functionality, our `Module` also provides `cuda` and `training` attributes, which we'll use shortly.\n\nNow we can create our first `Module`, which is `ConvLayer`:\n\nWe're not implementing `F.conv2d` from scratch, since you should have already done that (using `unfold`) in the questionnaire in <<chapter_foundations>>. Instead, we're just creating a small class that wraps it up along with bias and weight initialization. Let's check that it works correctly with `Module.parameters`:\n\nAnd that we can call it (which will result in `forward` being called):\n\nIn the same way, we can implement `Linear`:\n\nand test if it works:\n\nLet's also create a testing module to check that if we include multiple parameters as attributes, they are all correctly registered:\n\nSince we have a conv layer and a linear layer, each of which has weights and biases, we'd expect four parameters in total:\n\nWe should also find that calling `cuda` on this class puts all these parameters on the GPU:\n\nWe can now use those pieces to create a CNN.\n\n### Simple CNN\n\nAs we've seen, a `Sequential` class makes many architectures easier to implement, so let's make one:\n\nThe `forward` method here just calls each layer in turn. Note that we have to use the `register_modules` method we defined in `Module`, since otherwise the contents of `layers` won't appear in `parameters`.\n\n> important: All The Code is Here: Remember that we're not using any PyTorch functionality for modules here; we're defining everything ourselves. So if you're not sure what `register_modules` does, or why it's needed, have another look at our code for `Module` to see what we wrote!\n\nWe can create a simplified `AdaptivePool` that only handles pooling to a 1×1 output, and flattens it as well, by just using `mean`:\n\nThat's enough for us to create a CNN!\n\nLet's see if our parameters are all being registered correctly:\n\nNow we can try adding a hook. Note that we've only left room for one hook in `Module`; you could make it a list, or use something like `Pipeline` to run a few as a single function:\n\nWe have data and model. Now we need a loss function.\n\n## Loss\n\nWe've already seen how to define \"negative log likelihood\":\n\nWell actually, there's no log here, since we're using the same definition as PyTorch. That means we need to put the log together with softmax:\n\nCombining these gives us our cross-entropy loss:\n\nNote that the formula:\n\n$$\\log \\left ( \\frac{a}{b} \\right ) = \\log(a) - \\log(b)$$ \n\ngives a simplification when we compute the log softmax, which was previously defined as `(x.exp()/(x.exp().sum(-1))).log()`:\n\nThen, there is a more stable way to compute the log of the sum of exponentials, called the [LogSumExp](https://en.wikipedia.org/wiki/LogSumExp) trick. The idea is to use the following formula:\n\n$$\\log \\left ( \\sum_{j=1}^{n} e^{x_{j}} \\right ) = \\log \\left ( e^{a} \\sum_{j=1}^{n} e^{x_{j}-a} \\right ) = a + \\log \\left ( \\sum_{j=1}^{n} e^{x_{j}-a} \\right )$$\n\nwhere $a$ is the maximum of $x_{j}$.\n\n\nHere's the same thing in code:\n\nWe'll put that into a function:\n\nso we can use it for our `log_softmax` function:\n\nWhich gives the same result as before:\n\nWe can use these to create `cross_entropy`:\n\nLet's now combine all those pieces together to create a `Learner`.\n\n## Learner\n\nWe have data, a model, and a loss function; we only need one more thing before we can fit a model, and that's an optimizer! Here's SGD:\n\nAs we've seen in this book, life is easier with a `Learner`. The `Learner` class needs to know our training and validation sets, which means we need `DataLoaders` to store them. We don't need any other functionality, just a place to store them and access them:\n\nNow we're ready to create our `Learner` class:\n\nThis is the largest class we've created in the book, but each method is quite small, so by looking at each in turn you should be able to follow what's going on.\n\nThe main method we'll be calling is `fit`. This loops with:\n\n```python\nfor self.epoch in range(n_epochs)\n```\n\nand at each epoch calls `self.one_epoch` for each of `train=True` and then `train=False`. Then `self.one_epoch` calls `self.one_batch` for each batch in `dls.train` or `dls.valid`, as appropriate (after wrapping the `DataLoader` in `fastprogress.progress_bar`. Finally, `self.one_batch` follows the usual set of steps to fit one mini-batch that we've seen throughout this book.\n\nBefore and after each step, `Learner` calls `self`, which calls `__call__` (which is standard Python functionality). `__call__` uses `getattr(cb,name)` on each callback in `self.cbs`, which is a Python built-in function that returns the attribute (a method, in this case) with the requested name. So, for instance, `self('before_fit')` will call `cb.before_fit()` for each callback where that method is defined.\n\nAs you can see, `Learner` is really just using our standard training loop, except that it's also calling callbacks at appropriate times. So let's define some callbacks!\n\n### Callbacks\n\nIn `Learner.__init__` we have:\n\n```python\nfor cb in cbs: cb.learner = self\n```\n\nIn other words, every callback knows what learner it is used in. This is critical, since otherwise a callback can't get information from the learner, or change things in the learner. Because getting information from the learner is so common, we make that easier by defining `Callback` as a subclass of `GetAttr`, with a default attribute of `learner`:\n\n`GetAttr` is a fastai class that implements Python's standard `__getattr__` and `__dir__` methods for you, such that any time you try to access an attribute that doesn't exist, it passes the request along to whatever you have defined as `_default`.\n\nFor instance, we want to move all model parameters to the GPU automatically at the start of `fit`. We could do this by defining `before_fit` as `self.learner.model.cuda()`; however, because `learner` is the default attribute, and we have `SetupLearnerCB` inherit from `Callback` (which inherits from `GetAttr`), we can remove the `.learner` and just call `self.model.cuda()`:\n\nIn `SetupLearnerCB` we also move each mini-batch to the GPU, by calling `to_device(self.batch)` (we could also have used the longer `to_device(self.learner.batch)`. Note however that in the line `self.learner.batch = tfm_x(xb),yb` we can't remove `.learner`, because here we're *setting* the attribute, not getting it.\n\nBefore we try our `Learner` out, let's create a callback to track and print progress. Otherwise we won't really know if it's working properly:\n\nNow we're ready to use our `Learner` for the first time!\n\nIt's quite amazing to realize that we can implement all the key ideas from fastai's `Learner` in so little code! Let's now add some learning rate scheduling.\n\n### Scheduling the Learning Rate\n\nIf we're going to get good results, we'll want an LR finder and 1cycle training. These are both *annealing* callbacks—that is, they are gradually changing hyperparameters as we train. Here's `LRFinder`:\n\nThis shows how we're using `CancelFitException`, which is itself an empty class, only used to signify the type of exception. You can see in `Learner` that this exception is caught. (You should add and test `CancelBatchException`, `CancelEpochException`, etc. yourself.) Let's try it out, by adding it to our list of callbacks:\n\nAnd take a look at the results:\n\nNow we can define our `OneCycle` training callback:\n\nWe'll try an LR of 0.1:\n\nLet's fit for a while and see how it looks (we won't show all the output in the book—try it in the notebook to see the results):\n\nFinally, we'll check that the learning rate followed the schedule we defined (as you see, we're not using cosine annealing here):\n\n## Conclusion\n\nWe have explored how the key concepts of the fastai library are implemented by re-implementing them in this chapter. Since it's mostly full of code, you should definitely try to experiment with it by looking at the corresponding notebook on the book's website. Now that you know how it's built, as a next step be sure to check out the intermediate and advanced tutorials in the fastai documentation to learn how to customize every bit of the library.\n\n## Questionnaire\n\n> tip: Experiments: For the questions here that ask you to explain what some function or class is, you should also complete your own code experiments.\n\n1. What is `glob`?\n1. How do you open an image with the Python imaging library?\n1. What does `L.map` do?\n1. What does `Self` do?\n1. What is `L.val2idx`?\n1. What methods do you need to implement to create your own `Dataset`?\n1. Why do we call `convert` when we open an image from Imagenette?\n1. What does `~` do? How is it useful for splitting training and validation sets?\n1. Does `~` work with the `L` or `Tensor` classes? What about NumPy arrays, Python lists, or pandas DataFrames?\n1. What is `ProcessPoolExecutor`?\n1. How does `L.range(self.ds)` work?\n1. What is `__iter__`?\n1. What is `first`?\n1. What is `permute`? Why is it needed?\n1. What is a recursive function? How does it help us define the `parameters` method?\n1. Write a recursive function that returns the first 20 items of the Fibonacci sequence.\n1. What is `super`?\n1. Why do subclasses of `Module` need to override `forward` instead of defining `__call__`?\n1. In `ConvLayer`, why does `init` depend on `act`?\n1. Why does `Sequential` need to call `register_modules`?\n1. Write a hook that prints the shape of every layer's activations.\n1. What is \"LogSumExp\"?\n1. Why is `log_softmax` useful?\n1. What is `GetAttr`? How is it helpful for callbacks?\n1. Reimplement one of the callbacks in this chapter without inheriting from `Callback` or `GetAttr`.\n1. What does `Learner.__call__` do?\n1. What is `getattr`? (Note the case difference to `GetAttr`!)\n1. Why is there a `try` block in `fit`?\n1. Why do we check for `model.training` in `one_batch`?\n1. What is `store_attr`?\n1. What is the purpose of `TrackResults.before_epoch`?\n1. What does `model.cuda` do? How does it work?\n1. Why do we need to check `model.training` in `LRFinder` and `OneCycle`?\n1. Use cosine annealing in `OneCycle`.\n\n### Further Research\n\n1. Write `resnet18` from scratch (refer to <<chapter_resnet>> as needed), and train it with the `Learner` in this chapter.\n1. Implement a batchnorm layer from scratch and use it in your `resnet18`.\n1. Write a Mixup callback for use in this chapter.\n1. Add momentum to SGD.\n1. Pick a few features that you're interested in from fastai (or any other library) and implement them in this chapter.\n1. Pick a research paper that's not yet implemented in fastai or PyTorch and implement it in this chapter.\n  - Port it over to fastai.\n  - Submit a pull request to fastai, or create your own extension module and release it. \n  - Hint: you may find it helpful to use [`nbdev`](https://nbdev.fast.ai/) to create and deploy your package.\n","srcMarkdownNoYaml":"\n\n\n\n\n\n\nThis final chapter (other than the conclusion and the online chapters) is going to look a bit different. It contains far more code and far less prose than the previous chapters. We will introduce new Python keywords and libraries without discussing them. This chapter is meant to be the start of a significant research project for you. You see, we are going to implement many of the key pieces of the fastai and PyTorch APIs from scratch, building on nothing other than the components that we developed in <<chapter_foundations>>! The key goal here is to end up with your own `Learner` class, and some callbacks—enough to be able to train a model on Imagenette, including examples of each of the key techniques we've studied. On the way to building `Learner`, we will create our own version of `Module`, `Parameter`, and parallel `DataLoader` so you have a very good idea of what those PyTorch classes do.\n\nThe end-of-chapter questionnaire is particularly important for this chapter. This is where we will be pointing you in the many interesting directions that you could take, using this chapter as your starting point. We suggest that you follow along with this chapter on your computer, and do lots of experiments, web searches, and whatever else you need to understand what's going on. You've built up the skills and expertise to do this in the rest of this book, so we think you are going to do great!\n\nLet's begin by gathering (manually) some data.\n\n## Data\n\nHave a look at the source to `untar_data` to see how it works. We'll use it here to access the 160-pixel version of Imagenette for use in this chapter:\n\nTo access the image files, we can use `get_image_files`:\n\nOr we could do the same thing using just Python's standard library, with `glob`:\n\nIf you look at the source for `get_image_files`, you'll see it uses Python's `os.walk`; this is a faster and more flexible function than `glob`, so be sure to try it out.\n\nWe can open an image with the Python Imaging Library's `Image` class:\n\nThat's going to be the basis of our independent variable. For our dependent variable, we can use `Path.parent` from `pathlib`. First we'll need our vocab:\n\n...and the reverse mapping, thanks to `L.val2idx`:\n\nThat's all the pieces we need to put together our `Dataset`.\n\n### Dataset\n\nA `Dataset` in PyTorch can be anything that supports indexing (`__getitem__`) and `len`:\n\nWe need a list of training and validation filenames to pass to `Dataset.__init__`:\n\nNow we can try it out:\n\nAs you see, our dataset is returning the independent and dependent variables as a tuple, which is just what we need. We'll need to be able to collate these into a mini-batch. Generally this is done with `torch.stack`, which is what we'll use here:\n\nHere's a mini-batch with two items, for testing our `collate`:\n\nNow that we have a dataset and a collation function, we're ready to create `DataLoader`. We'll add two more things here: an optional `shuffle` for the training set, and a `ProcessPoolExecutor` to do our preprocessing in parallel. A parallel data loader is very important, because opening and decoding a JPEG image is a slow process. One CPU core is not enough to decode images fast enough to keep a modern GPU busy. Here's our `DataLoader` class:\n\nLet's try it out with our training and validation datasets:\n\nThis data loader is not much slower than PyTorch's, but it's far simpler. So if you're debugging a complex data loading process, don't be afraid to try doing things manually to help you see exactly what's going on.\n\nFor normalization, we'll need image statistics. Generally it's fine to calculate these on a single training mini-batch, since precision isn't needed here:\n\nOur `Normalize` class just needs to store these stats and apply them (to see why the `to_device` is needed, try commenting it out, and see what happens later in this notebook):\n\nWe always like to test everything we build in a notebook, as soon as we build it:\n\nHere `tfm_x` isn't just applying `Normalize`, but is also permuting the axis order from `NHWC` to `NCHW` (see <<chapter_convolutions>> if you need a reminder of what these acronyms refer to). PIL uses `HWC` axis order, which we can't use with PyTorch, hence the need for this `permute`.\n\nThat's all we need for the data for our model. So now we need the model itself!\n\n## Module and Parameter\n\nTo create a model, we'll need `Module`. To create `Module`, we'll need `Parameter`, so let's start there. Recall that in <<chapter_collab>> we said that the `Parameter` class \"doesn't actually add any functionality (other than automatically calling `requires_grad_` for us). It's only used as a \"marker\" to show what to include in `parameters`.\" Here's a definition which does exactly that:\n\nThe implementation here is a bit awkward: we have to define the special `__new__` Python method and use the internal PyTorch method `_make_subclass` because, as at the time of writing, PyTorch doesn't otherwise work correctly with this kind of subclassing or provide an officially supported API to do this. This may have been fixed by the time you read this, so look on the book's website to see if there are updated details.\n\nOur `Parameter` now behaves just like a tensor, as we wanted:\n\nNow that we have this, we can define `Module`:\n\nThe key functionality is in the definition of `parameters`:\n\n```python\nself.params + sum([m.parameters() for m in self.children], [])\n```\n\nThis means that we can ask any `Module` for its parameters, and it will return them, including all its child modules (recursively). But how does it know what its parameters are? It's thanks to implementing Python's special `__setattr__` method, which is called for us any time Python sets an attribute on a class. Our implementation includes this line:\n\n```python\nif isinstance(v,Parameter): self.register_parameters(v)\n```\n\nAs you see, this is where we use our new `Parameter` class as a \"marker\"—anything of this class is added to our `params`.\n\nPython's `__call__` allows us to define what happens when our object is treated as a function; we just call `forward` (which doesn't exist here, so it'll need to be added by subclasses). Before we do, we'll call a hook, if it's defined. Now you can see that PyTorch hooks aren't doing anything fancy at all—they're just calling any hooks that have been registered.\n\nOther than these pieces of functionality, our `Module` also provides `cuda` and `training` attributes, which we'll use shortly.\n\nNow we can create our first `Module`, which is `ConvLayer`:\n\nWe're not implementing `F.conv2d` from scratch, since you should have already done that (using `unfold`) in the questionnaire in <<chapter_foundations>>. Instead, we're just creating a small class that wraps it up along with bias and weight initialization. Let's check that it works correctly with `Module.parameters`:\n\nAnd that we can call it (which will result in `forward` being called):\n\nIn the same way, we can implement `Linear`:\n\nand test if it works:\n\nLet's also create a testing module to check that if we include multiple parameters as attributes, they are all correctly registered:\n\nSince we have a conv layer and a linear layer, each of which has weights and biases, we'd expect four parameters in total:\n\nWe should also find that calling `cuda` on this class puts all these parameters on the GPU:\n\nWe can now use those pieces to create a CNN.\n\n### Simple CNN\n\nAs we've seen, a `Sequential` class makes many architectures easier to implement, so let's make one:\n\nThe `forward` method here just calls each layer in turn. Note that we have to use the `register_modules` method we defined in `Module`, since otherwise the contents of `layers` won't appear in `parameters`.\n\n> important: All The Code is Here: Remember that we're not using any PyTorch functionality for modules here; we're defining everything ourselves. So if you're not sure what `register_modules` does, or why it's needed, have another look at our code for `Module` to see what we wrote!\n\nWe can create a simplified `AdaptivePool` that only handles pooling to a 1×1 output, and flattens it as well, by just using `mean`:\n\nThat's enough for us to create a CNN!\n\nLet's see if our parameters are all being registered correctly:\n\nNow we can try adding a hook. Note that we've only left room for one hook in `Module`; you could make it a list, or use something like `Pipeline` to run a few as a single function:\n\nWe have data and model. Now we need a loss function.\n\n## Loss\n\nWe've already seen how to define \"negative log likelihood\":\n\nWell actually, there's no log here, since we're using the same definition as PyTorch. That means we need to put the log together with softmax:\n\nCombining these gives us our cross-entropy loss:\n\nNote that the formula:\n\n$$\\log \\left ( \\frac{a}{b} \\right ) = \\log(a) - \\log(b)$$ \n\ngives a simplification when we compute the log softmax, which was previously defined as `(x.exp()/(x.exp().sum(-1))).log()`:\n\nThen, there is a more stable way to compute the log of the sum of exponentials, called the [LogSumExp](https://en.wikipedia.org/wiki/LogSumExp) trick. The idea is to use the following formula:\n\n$$\\log \\left ( \\sum_{j=1}^{n} e^{x_{j}} \\right ) = \\log \\left ( e^{a} \\sum_{j=1}^{n} e^{x_{j}-a} \\right ) = a + \\log \\left ( \\sum_{j=1}^{n} e^{x_{j}-a} \\right )$$\n\nwhere $a$ is the maximum of $x_{j}$.\n\n\nHere's the same thing in code:\n\nWe'll put that into a function:\n\nso we can use it for our `log_softmax` function:\n\nWhich gives the same result as before:\n\nWe can use these to create `cross_entropy`:\n\nLet's now combine all those pieces together to create a `Learner`.\n\n## Learner\n\nWe have data, a model, and a loss function; we only need one more thing before we can fit a model, and that's an optimizer! Here's SGD:\n\nAs we've seen in this book, life is easier with a `Learner`. The `Learner` class needs to know our training and validation sets, which means we need `DataLoaders` to store them. We don't need any other functionality, just a place to store them and access them:\n\nNow we're ready to create our `Learner` class:\n\nThis is the largest class we've created in the book, but each method is quite small, so by looking at each in turn you should be able to follow what's going on.\n\nThe main method we'll be calling is `fit`. This loops with:\n\n```python\nfor self.epoch in range(n_epochs)\n```\n\nand at each epoch calls `self.one_epoch` for each of `train=True` and then `train=False`. Then `self.one_epoch` calls `self.one_batch` for each batch in `dls.train` or `dls.valid`, as appropriate (after wrapping the `DataLoader` in `fastprogress.progress_bar`. Finally, `self.one_batch` follows the usual set of steps to fit one mini-batch that we've seen throughout this book.\n\nBefore and after each step, `Learner` calls `self`, which calls `__call__` (which is standard Python functionality). `__call__` uses `getattr(cb,name)` on each callback in `self.cbs`, which is a Python built-in function that returns the attribute (a method, in this case) with the requested name. So, for instance, `self('before_fit')` will call `cb.before_fit()` for each callback where that method is defined.\n\nAs you can see, `Learner` is really just using our standard training loop, except that it's also calling callbacks at appropriate times. So let's define some callbacks!\n\n### Callbacks\n\nIn `Learner.__init__` we have:\n\n```python\nfor cb in cbs: cb.learner = self\n```\n\nIn other words, every callback knows what learner it is used in. This is critical, since otherwise a callback can't get information from the learner, or change things in the learner. Because getting information from the learner is so common, we make that easier by defining `Callback` as a subclass of `GetAttr`, with a default attribute of `learner`:\n\n`GetAttr` is a fastai class that implements Python's standard `__getattr__` and `__dir__` methods for you, such that any time you try to access an attribute that doesn't exist, it passes the request along to whatever you have defined as `_default`.\n\nFor instance, we want to move all model parameters to the GPU automatically at the start of `fit`. We could do this by defining `before_fit` as `self.learner.model.cuda()`; however, because `learner` is the default attribute, and we have `SetupLearnerCB` inherit from `Callback` (which inherits from `GetAttr`), we can remove the `.learner` and just call `self.model.cuda()`:\n\nIn `SetupLearnerCB` we also move each mini-batch to the GPU, by calling `to_device(self.batch)` (we could also have used the longer `to_device(self.learner.batch)`. Note however that in the line `self.learner.batch = tfm_x(xb),yb` we can't remove `.learner`, because here we're *setting* the attribute, not getting it.\n\nBefore we try our `Learner` out, let's create a callback to track and print progress. Otherwise we won't really know if it's working properly:\n\nNow we're ready to use our `Learner` for the first time!\n\nIt's quite amazing to realize that we can implement all the key ideas from fastai's `Learner` in so little code! Let's now add some learning rate scheduling.\n\n### Scheduling the Learning Rate\n\nIf we're going to get good results, we'll want an LR finder and 1cycle training. These are both *annealing* callbacks—that is, they are gradually changing hyperparameters as we train. Here's `LRFinder`:\n\nThis shows how we're using `CancelFitException`, which is itself an empty class, only used to signify the type of exception. You can see in `Learner` that this exception is caught. (You should add and test `CancelBatchException`, `CancelEpochException`, etc. yourself.) Let's try it out, by adding it to our list of callbacks:\n\nAnd take a look at the results:\n\nNow we can define our `OneCycle` training callback:\n\nWe'll try an LR of 0.1:\n\nLet's fit for a while and see how it looks (we won't show all the output in the book—try it in the notebook to see the results):\n\nFinally, we'll check that the learning rate followed the schedule we defined (as you see, we're not using cosine annealing here):\n\n## Conclusion\n\nWe have explored how the key concepts of the fastai library are implemented by re-implementing them in this chapter. Since it's mostly full of code, you should definitely try to experiment with it by looking at the corresponding notebook on the book's website. Now that you know how it's built, as a next step be sure to check out the intermediate and advanced tutorials in the fastai documentation to learn how to customize every bit of the library.\n\n## Questionnaire\n\n> tip: Experiments: For the questions here that ask you to explain what some function or class is, you should also complete your own code experiments.\n\n1. What is `glob`?\n1. How do you open an image with the Python imaging library?\n1. What does `L.map` do?\n1. What does `Self` do?\n1. What is `L.val2idx`?\n1. What methods do you need to implement to create your own `Dataset`?\n1. Why do we call `convert` when we open an image from Imagenette?\n1. What does `~` do? How is it useful for splitting training and validation sets?\n1. Does `~` work with the `L` or `Tensor` classes? What about NumPy arrays, Python lists, or pandas DataFrames?\n1. What is `ProcessPoolExecutor`?\n1. How does `L.range(self.ds)` work?\n1. What is `__iter__`?\n1. What is `first`?\n1. What is `permute`? Why is it needed?\n1. What is a recursive function? How does it help us define the `parameters` method?\n1. Write a recursive function that returns the first 20 items of the Fibonacci sequence.\n1. What is `super`?\n1. Why do subclasses of `Module` need to override `forward` instead of defining `__call__`?\n1. In `ConvLayer`, why does `init` depend on `act`?\n1. Why does `Sequential` need to call `register_modules`?\n1. Write a hook that prints the shape of every layer's activations.\n1. What is \"LogSumExp\"?\n1. Why is `log_softmax` useful?\n1. What is `GetAttr`? How is it helpful for callbacks?\n1. Reimplement one of the callbacks in this chapter without inheriting from `Callback` or `GetAttr`.\n1. What does `Learner.__call__` do?\n1. What is `getattr`? (Note the case difference to `GetAttr`!)\n1. Why is there a `try` block in `fit`?\n1. Why do we check for `model.training` in `one_batch`?\n1. What is `store_attr`?\n1. What is the purpose of `TrackResults.before_epoch`?\n1. What does `model.cuda` do? How does it work?\n1. Why do we need to check `model.training` in `LRFinder` and `OneCycle`?\n1. Use cosine annealing in `OneCycle`.\n\n### Further Research\n\n1. Write `resnet18` from scratch (refer to <<chapter_resnet>> as needed), and train it with the `Learner` in this chapter.\n1. Implement a batchnorm layer from scratch and use it in your `resnet18`.\n1. Write a Mixup callback for use in this chapter.\n1. Add momentum to SGD.\n1. Pick a few features that you're interested in from fastai (or any other library) and implement them in this chapter.\n1. Pick a research paper that's not yet implemented in fastai or PyTorch and implement it in this chapter.\n  - Port it over to fastai.\n  - Submit a pull request to fastai, or create your own extension module and release it. \n  - Hint: you may find it helpful to use [`nbdev`](https://nbdev.fast.ai/) to create and deploy your package.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"19_learner.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.24","theme":"darkly","toc-location":"left","code-summary":"Show code","title":"A fastai Learner from Scratch"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}